[gd_scene load_steps=10 format=2]

[ext_resource path="res://ClayJohnErosion.shader" type="Shader" id=1]
[ext_resource path="res://roads.shader" type="Shader" id=2]

[sub_resource type="PlaneMesh" id=1]
size = Vector2( 20, 20 )
subdivide_width = 100
subdivide_depth = 100

[sub_resource type="ShaderMaterial" id=2]
shader = ExtResource( 1 )
shader_param/height_scale = 3.84
shader_param/seed = 1.8
shader_param/noise_direction = 0.16
shader_param/mountain_color = Color( 0.45098, 0.403922, 0.372549, 1 )
shader_param/grass_color = Color( 0.321569, 0.65098, 0.211765, 1 )
shader_param/mountain_strength = 1.196
shader_param/grass_start = -0.202
shader_param/ridge_influence = 1.788
shader_param/experimental = false
shader_param/erosion_normal_strength = 0.0
shader_param/erosion_strength = 0.072
shader_param/scale = 0.514

[sub_resource type="PlaneMesh" id=3]
size = Vector2( 20, 20 )

[sub_resource type="ShaderMaterial" id=4]
shader = ExtResource( 2 )
shader_param/seed = 0.42
shader_param/scale = 2.98
shader_param/small_scale = 10.4
shader_param/road_treshold = 0.018
shader_param/small_road_treshold = 0.032
shader_param/small_end = 0.308
shader_param/pointiness = 0.632
shader_param/noise_strength = 0.654
shader_param/n_scale = 1.074
shader_param/n_num_layers = 3
shader_param/n_persistence = 0.5
shader_param/n_lacunarity = 2.0
shader_param/grass_color = Color( 0.364706, 0.733333, 0.309804, 1 )
shader_param/road_color = Color( 0.368627, 0.317647, 0.223529, 1 )

[sub_resource type="Shader" id=5]
code = "shader_type spatial;

uniform float scale;
uniform float big_scale;
uniform float displacement_fac;
uniform float e = 0.001;
uniform float in_angle = 0;
uniform float d_pow = 0;
uniform float squish = 0;
uniform float angle_step = 10;

float hash(vec2 p) {
	return fract(sin(dot(p * 17.17, vec2(14.91, 67.31))) * 4791.9511);
}

float noise(vec2 x) {
	vec2 p = floor(x);
	vec2 f = fract(x);
	f = f * f * (3.0 - 2.0 * f);
	vec2 a = vec2(1.0, 0.0);
	return mix(mix(hash(p + a.yy), hash(p + a.xy), f.x),
		mix(hash(p + a.yx), hash(p + a.xx), f.x), f.y);
}

float fbm(vec2 x, int layers, float frequency, float persistence, float lacunarity) {
	float height = 0.0;
	float amplitude = 0.5;
	float max_possible = 0.0;
	
	for (int i = 0; i < layers; i++){
		height += noise(x * frequency) * amplitude;
		max_possible += amplitude;
		amplitude *= persistence;
		frequency *= lacunarity;
	}
	return height / (max_possible * 0.9);
}

float noise2lvl(vec2 x) {
	return fbm(x, 2, 1.0, 0.5, 2.0);
}

float noise_with_direction(vec2 x, float v) {
	while (v < -3.141592) {
		v += 2.0 * 3.141592
	}
	while (v > 3.141592) {
		v -= 2.0 * 3.141592
	}
	x += (vec2(hash(vec2(v * 100.0, v * 100.0))) - 0.5) * 100.0;
	vec2 x_rotated = vec2(x.x * cos(v) - x.y * sin(v), x.y * cos(v) + x.x * sin(v));
	x_rotated *= vec2(squish, 1.0);
	float h = noise(x_rotated);
	return h;
}

float atan2(float y, float x) {
	if (x > 0.0) {
		return atan(y / x);
	} else if (x < 0.0 && y >= 0.0) {
		return atan(y / x) + 3.141592;
	} else if (x < 0.0 && y < 0.0) {
		return atan(y / x) - 3.141592;
	}
}

void fragment() {
	vec2 pos = UV * big_scale;
	float p = noise2lvl(pos);
	float px = noise2lvl(pos + vec2(1, 0) * e);
	float py = noise2lvl(pos + vec2(0, 1) * e);
	vec2 d = vec2((px - p) / e, (py - p) / e);

	pos = UV * scale;
	float angle = atan2(d.y, d.x);
	float dir = floor(angle / angle_step) * angle_step;
	float in_fac = (angle - dir) / angle_step;
	float ha = noise_with_direction(pos, dir);
	float hb = noise_with_direction(pos, dir + angle_step);
	
	float h = ha + (hb - ha) * in_fac;
	
	vec3 color = vec3(h);
	ALBEDO = color;
}
/*
void fragment() {
	vec2 pos = UV * scale;
	float p = noise2lvl(pos);
	float px = noise2lvl(pos + vec2(1, 0) * e);
	float py = noise2lvl(pos + vec2(0, 1) * e);
	vec2 d = vec2((px - p) / e, (py - p) / e);
	float derivate_magnitude = distance(d, vec2(0, 0));
	vec2 dir = vec2(cos(angle), sin(angle));
	vec2 projected_derivate = (dot(d, dir) / pow(distance(vec2(0, 0), dir), 2)) * dir;
	vec2 displaced_pos = pos + projected_derivate * displacement_fac;
	
	vec3 color = vec3(noise(displaced_pos));
	ALBEDO = color;
}
*/"

[sub_resource type="ShaderMaterial" id=6]
shader = SubResource( 5 )
shader_param/scale = -14.8
shader_param/big_scale = 2.48
shader_param/displacement_fac = -0.36
shader_param/e = 0.001
shader_param/in_angle = 1.44
shader_param/d_pow = 5.12
shader_param/squish = 0.36
shader_param/angle_step = 0.2

[sub_resource type="PlaneMesh" id=7]
size = Vector2( 20, 20 )

[node name="Spatial" type="Spatial"]

[node name="MeshInstance" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 10, 0, 0 )
visible = false
mesh = SubResource( 1 )
material/0 = SubResource( 2 )

[node name="DirectionalLight" type="DirectionalLight" parent="."]
transform = Transform( -0.428809, 0.882465, 0.193335, -0.388336, -0.373287, 0.842527, 0.81567, 0.286205, 0.502762, 1.34906, 10.0545, 4.13562 )
light_color = Color( 1, 0.878431, 0.709804, 1 )

[node name="MeshInstance2" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -10, 0, 0 )
mesh = SubResource( 3 )
material/0 = SubResource( 4 )

[node name="MeshInstance3" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -10, 0, 20 )
material_override = SubResource( 6 )
mesh = SubResource( 7 )
material/0 = null
